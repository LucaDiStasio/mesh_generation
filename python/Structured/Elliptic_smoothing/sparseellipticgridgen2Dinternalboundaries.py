# Autogenerated with SMOP 
from smop.core import *
# 

    
@function
def sparseellipticgridgen2Dinternalboundaries(Nx=None,N=None,lattice=None,deltaq=None,boundary=None,flagperiodicity=None,periodicity=None,indicesbulk=None,indicesE1=None,indicesE2=None,indicesE3=None,indicesE4=None,indicesC1=None,indicesC2=None,indicesC3=None,indicesC4=None,firstdevneighbours=None,itmax=None,tol=None,spy=None,*args,**kwargs):
    varargin = sparseellipticgridgen2Dinternalboundaries.varargin
    nargin = sparseellipticgridgen2Dinternalboundaries.nargin

    ##
#        Project: Fluid-Structure Interaction on Deformable Surfaces
#         Author: Luca Di Stasio
#    Institution: ETH Zrich
#                 Institute for Building Materials
# Research group: Computational Physics for Engineering Materials
#        Version: 0.1
#  Creation date: July 17th, 2014
#    Last update: August 7th, 2014
    
    #          Input: meshed computational domain compdomain
#         Output: mesh in the physical domain
    
    ##
    
    if logical_not(flagperiodicity):
        boundaryindices=matlabarray(cat([indicesE1],[indicesE2],[indicesE3],[indicesE4],[indicesC1],[indicesC2],[indicesC3],[indicesC4],[boundary]))
    else:
        if any(periodicity == 1) and logical_not(any(periodicity == 2)) and logical_not(any(periodicity == 3)) and logical_not(any(periodicity == 4)):
            boundaryindices=matlabarray(cat([indicesE2],[indicesE4],[indicesC1],[indicesC2],[indicesC3],[indicesC4],[boundary]))
        else:
            if logical_not(any(periodicity == 1)) and any(periodicity == 2) and logical_not(any(periodicity == 3)) and logical_not(any(periodicity == 4)):
                boundaryindices=matlabarray(cat([indicesE1],[indicesE3],[indicesC1],[indicesC2],[indicesC3],[indicesC4],[boundary]))
            else:
                if logical_not(any(periodicity == 1)) and logical_not(any(periodicity == 2)) and any(periodicity == 3) and logical_not(any(periodicity == 4)):
                    pass
                else:
                    if logical_not(any(periodicity == 1)) and logical_not(any(periodicity == 2)) and logical_not(any(periodicity == 3)) and any(periodicity == 4):
                        pass
                    else:
                        if any(periodicity == 1) and any(periodicity == 2) and logical_not(any(periodicity == 3)) and logical_not(any(periodicity == 4)):
                            boundaryindices=matlabarray(cat([indicesC1],[indicesC2],[indicesC3],[indicesC4],[boundary]))
                        else:
                            if any(periodicity == 1) and any(periodicity == 2) and any(periodicity == 3) and any(periodicity == 4):
                                boundaryindices=matlabarray(cat(boundary))
    
    effectivebulk=matlabarray([])
    for i in arange(1,N).reshape(-1):
        if logical_not(any(boundaryindices == i)):
            effectivebulk=matlabarray(cat([effectivebulk],[i]))
    
    it=0
    err=1
    if spy:
        covariantbase=computecovariantbase2D(N,deltaq,lattice,firstdevneighbours)
        metriccoefficients=computemetriccoefficients2D(covariantbase)
        clear('covariantbase')
        A=sparse(cat([boundaryindices],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk]),cat([boundaryindices],[effectivebulk],[effectivebulk - 1],[effectivebulk + 1],[effectivebulk - Nx],[effectivebulk + Nx],[effectivebulk - 1 - Nx],[effectivebulk + 1 - Nx],[effectivebulk - 1 + Nx],[effectivebulk + 1 + Nx]),cat([ones(size(boundaryindices,1),1)],[dot(- 2,(metriccoefficients[effectivebulk,2] / (deltaq[1] ** 2) + metriccoefficients[effectivebulk,1] / (deltaq[2] ** 2)))],[metriccoefficients[effectivebulk,2] / (deltaq[1] ** 2)],[metriccoefficients[effectivebulk,2] / (deltaq[1] ** 2)],[metriccoefficients[effectivebulk,1] / (deltaq[2] ** 2)],[metriccoefficients[effectivebulk,1] / (deltaq[2] ** 2)],[dot(- 0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))]),N,N)
        figure()
        spy[A]
        hold('on')
        grid('on')
        title('Structure of solving matrix for 2D elliptic grid generation')
        clear('A','metriccoefficients')
    
    while it <= itmax and err >= tol:

        covariantbase=computecovariantbase2D(N,deltaq,lattice,firstdevneighbours)
        metriccoefficients,J=computemetriccoefficients2D(covariantbase,nargout=2)
        Pvec=sparse(P(lattice))
        Qvec=sparse(Q(lattice))
        #     bx = zeros(N,1);
#     by = zeros(N,1);
#     bx(boundaryindices,:) = lattice(boundaryindices,3);
#     by(boundaryindices,:) = lattice(boundaryindices,4);
#     bx(indicesbulk,:) = -(J(indicesbulk,:).^2).*(Pvec(indicesbulk,:).*covariantbase(indicesbulk,1)+Qvec(indicesbulk,:).*covariantbase(indicesbulk,3));
#     by(indicesbulk,:) = -(J(indicesbulk,:).^2).*(Pvec(indicesbulk,:).*covariantbase(indicesbulk,2)+Qvec(indicesbulk,:).*covariantbase(indicesbulk,4));
        bx=sparse(cat([boundaryindices],[effectivebulk]),cat([ones(length(boundaryindices),1)],[ones(length(effectivebulk),1)]),cat([lattice[boundaryindices,3]],[multiply(- (J[effectivebulk,:] ** 2),(multiply(Pvec[effectivebulk,:],covariantbase[effectivebulk,1]) + multiply(Qvec[effectivebulk,:],covariantbase[effectivebulk,3])))]),N,1)
        by=sparse(cat([boundaryindices],[effectivebulk]),cat([ones(length(boundaryindices),1)],[ones(length(effectivebulk),1)]),cat([lattice[boundaryindices,4]],[multiply(- (J[effectivebulk,:] ** 2),(multiply(Pvec[effectivebulk,:],covariantbase[effectivebulk,2]) + multiply(Qvec[effectivebulk,:],covariantbase[effectivebulk,4])))]),N,1)
        clear('covariantbase','Pvec','Qvec','J')
        A=sparse(cat([boundaryindices],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk]),cat([boundaryindices],[effectivebulk],[effectivebulk - 1],[effectivebulk + 1],[effectivebulk - Nx],[effectivebulk + Nx],[effectivebulk - 1 - Nx],[effectivebulk + 1 - Nx],[effectivebulk - 1 + Nx],[effectivebulk + 1 + Nx]),cat([ones(size(boundaryindices,1),1)],[dot(- 2,(metriccoefficients[effectivebulk,2] / (deltaq[1] ** 2) + metriccoefficients[effectivebulk,1] / (deltaq[2] ** 2)))],[metriccoefficients[effectivebulk,2] / (deltaq[1] ** 2)],[metriccoefficients[effectivebulk,2] / (deltaq[1] ** 2)],[metriccoefficients[effectivebulk,1] / (deltaq[2] ** 2)],[metriccoefficients[effectivebulk,1] / (deltaq[2] ** 2)],[dot(- 0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))]),N,N)
        #     A = speye(N);
#     A(indicesbulk,indicesbulk) = diag(-2*(metriccoefficients(indicesbulk,2)./(deltaq(1).^2)+metriccoefficients(indicesbulk,1)./(deltaq(2).^2)));
#     A(indicesbulk,indicesbulk-1) = A(indicesbulk,indicesbulk-1) + diag(metriccoefficients(indicesbulk,2)./(deltaq(1).^2));
#     A(indicesbulk,indicesbulk+1) = A(indicesbulk,indicesbulk+1) + diag(metriccoefficients(indicesbulk,2)./(deltaq(1).^2));
#     A(indicesbulk,indicesbulk-Nx) = A(indicesbulk,indicesbulk-Nx) + diag(metriccoefficients(indicesbulk,1)./(deltaq(2).^2));
#     A(indicesbulk,indicesbulk+Nx) = A(indicesbulk,indicesbulk+Nx) + diag(metriccoefficients(indicesbulk,1)./(deltaq(2).^2));
#     A(indicesbulk,indicesbulk-1-Nx) = A(indicesbulk,indicesbulk-1-Nx) + diag(-0.5*metriccoefficients(indicesbulk,3)./(deltaq(1).*deltaq(2)));
#     A(indicesbulk,indicesbulk+1-Nx) = A(indicesbulk,indicesbulk+1-Nx) + diag(0.5*metriccoefficients(indicesbulk,3)./(deltaq(1).*deltaq(2)));
#     A(indicesbulk,indicesbulk-1+Nx) = A(indicesbulk,indicesbulk-1+Nx) + diag(0.5*metriccoefficients(indicesbulk,3)./(deltaq(1).*deltaq(2)));
#     A(indicesbulk,indicesbulk+1+Nx) = A(indicesbulk,indicesbulk+1+Nx) + diag(-0.5*metriccoefficients(indicesbulk,3)./(deltaq(1).*deltaq(2)));
        lattice[:,5]=full(numpy.linalg.solve(A,bx))
        lattice[:,6]=full(numpy.linalg.solve(A,by))
        err=sqrt(sum(cat([bx - dot(A,lattice[:,5])],[by - dot(A,lattice[:,6])]) ** 2))
        it=it + 1
        clear('A','bx','by','metriccoefficients')

    
    return lattice
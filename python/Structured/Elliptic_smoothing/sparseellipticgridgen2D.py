# Autogenerated with SMOP 
from smop.core import *
# 

    
@function
def sparseellipticgridgen2D(Nx=None,N=None,lattice=None,deltaq=None,flagperiodicity=None,periodicity=None,indicesbulk=None,indicesE1=None,indicesE2=None,indicesE3=None,indicesE4=None,indicesC1=None,indicesC2=None,indicesC3=None,indicesC4=None,firstdevneighbours=None,itmax=None,tol=None,spyflag=None,*args,**kwargs):
    varargin = sparseellipticgridgen2D.varargin
    nargin = sparseellipticgridgen2D.nargin

    ##
#==============================================================================
# Copyright (c) 2016 Universit de Lorraine & Lule tekniska universitet
# Author: Luca Di Stasio <luca.distasio@gmail.com>
#                        <luca.distasio@ingpec.eu>
    
    # Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 
# Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in
# the documentation and/or other materials provided with the distribution
# Neither the name of the Universit de Lorraine or Lule tekniska universitet
# nor the names of its contributors may be used to endorse or promote products
# derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#==============================================================================
    
    #  DESCRIPTION
#  
#  A function to
    
    #          Input: meshed computational domain compdomain
#         Output: mesh in the physical domain
    
    ##
    
    boundaryindices=matlabarray([])
    periodicboundaryindices=matlabarray([])
    periodicrows=matlabarray([])
    periodiccolumns=matlabarray([])
    periodicvalues=matlabarray([])
    if logical_not(flagperiodicity):
        boundaryindices=matlabarray(cat([indicesE1],[indicesE2],[indicesE3],[indicesE4],[indicesC1],[indicesC2],[indicesC3],[indicesC4]))
    else:
        if any(periodicity == 1) and logical_not(any(periodicity == 2)) and logical_not(any(periodicity == 3)) and logical_not(any(periodicity == 4)):
            boundaryindices=matlabarray(cat([indicesE2],[indicesE4],[indicesC1],[indicesC2],[indicesC3],[indicesC4]))
            periodicboundaryindices=matlabarray(cat([indicesE1],[indicesE3]))
            periodicrows=matlabarray(cat([indicesE1],[indicesE1],[indicesE1],[indicesE1],[indicesE1],[indicesE1],[indicesE1],[indicesE1],[indicesE1],[indicesE3],[indicesE3],[indicesE3],[indicesE3],[indicesE3],[indicesE3],[indicesE3],[indicesE3],[indicesE3]))
            periodiccolumns=matlabarray(cat([indicesE1],[indicesE1 - 1],[indicesE1 + 1],[indicesE3],[indicesE1 + Nx],[indicesE3 - 1],[indicesE3 + 1],[indicesE1 - 1 + Nx],[indicesE1 + 1 + Nx],[indicesE3],[indicesE3 - 1],[indicesE3 + 1],[indicesE3 - Nx],[indicesE1],[indicesE3 - 1 - Nx],[indicesE3 + 1 - Nx],[indicesE1 - 1],[indicesE1 + 1]))
        else:
            if logical_not(any(periodicity == 1)) and any(periodicity == 2) and logical_not(any(periodicity == 3)) and logical_not(any(periodicity == 4)):
                boundaryindices=matlabarray(cat([indicesE1],[indicesE3],[indicesC1],[indicesC2],[indicesC3],[indicesC4]))
                periodicboundaryindices=matlabarray(cat([indicesE2],[indicesE4]))
                periodicrows=matlabarray(cat([indicesE2],[indicesE2],[indicesE2],[indicesE2],[indicesE2],[indicesE2],[indicesE2],[indicesE2],[indicesE2],[indicesE4],[indicesE4],[indicesE4],[indicesE4],[indicesE4],[indicesE4],[indicesE4],[indicesE4],[indicesE4]))
                periodiccolumns=matlabarray(cat([indicesE2],[indicesE2 - 1],[indicesE4],[indicesE2 - Nx],[indicesE2 + Nx],[indicesE2 - 1 - Nx],[indicesE4 - Nx],[indicesE2 - 1 + Nx],[indicesE4 + Nx],[indicesE4],[indicesE2],[indicesE4 + 1],[indicesE4 - Nx],[indicesE4 + Nx],[indicesE2 - Nx],[indicesE4 + 1 - Nx],[indicesE2 + Nx],[indicesE4 + 1 + Nx]))
                #elseif ~any(periodicity==1) && ~any(periodicity==2) &&  any(periodicity==3) && ~any(periodicity==4)
                #elseif ~any(periodicity==1) && ~any(periodicity==2) && ~any(periodicity==3) &&  any(periodicity==4)
            else:
                if any(periodicity == 1) and any(periodicity == 2) and logical_not(any(periodicity == 3)) and logical_not(any(periodicity == 4)):
                    boundaryindices=matlabarray(cat([indicesC1],[indicesC2],[indicesC3],[indicesC4]))
                    periodicboundaryindices=matlabarray(cat([indicesE1],[indicesE2],[indicesE3],[indicesE4]))
                else:
                    if any(periodicity == 1) and any(periodicity == 2) and any(periodicity == 3) and any(periodicity == 4):
                        boundaryindices=matlabarray([])
                        periodicboundaryindices=matlabarray(cat([indicesE1],[indicesE2],[indicesE3],[indicesE4],[indicesC1],[indicesC2],[indicesC3],[indicesC4]))
    
    effectivebulk=matlabarray([])
    for i in arange(1,N).reshape(-1):
        if logical_not(any(boundaryindices == i)) and logical_not(any(periodicboundaryindices == i)):
            effectivebulk=matlabarray(cat([effectivebulk],[i]))
    
    it=0
    err=1
    if spyflag:
        covariantbase=computecovariantbase2D(N,deltaq,lattice,firstdevneighbours)
        metriccoefficients=computemetriccoefficients2D(covariantbase)
        clear('covariantbase')
        if logical_not(flagperiodicity):
            periodicvalues=matlabarray([])
        else:
            if any(periodicity == 1) and logical_not(any(periodicity == 2)) and logical_not(any(periodicity == 3)) and logical_not(any(periodicity == 4)):
                periodicvalues=matlabarray(cat([dot(- 2,(metriccoefficients[indicesE1,2] / (deltaq[1] ** 2) + metriccoefficients[indicesE1,1] / (deltaq[2] ** 2)))],[metriccoefficients[indicesE1,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE1,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE1,1] / (deltaq[2] ** 2)],[metriccoefficients[indicesE1,1] / (deltaq[2] ** 2)],[dot(- 0.5,metriccoefficients[indicesE1,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE1,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE1,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,metriccoefficients[indicesE1,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 2,(metriccoefficients[indicesE3,2] / (deltaq[1] ** 2) + metriccoefficients[indicesE3,1] / (deltaq[2] ** 2)))],[metriccoefficients[indicesE3,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE3,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE3,1] / (deltaq[2] ** 2)],[metriccoefficients[indicesE3,1] / (deltaq[2] ** 2)],[dot(- 0.5,metriccoefficients[indicesE3,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE3,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE3,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,metriccoefficients[indicesE3,3]) / (multiply(deltaq[1],deltaq[2]))]))
            else:
                if logical_not(any(periodicity == 1)) and any(periodicity == 2) and logical_not(any(periodicity == 3)) and logical_not(any(periodicity == 4)):
                    periodicvalues=matlabarray(cat([dot(- 2,(metriccoefficients[indicesE2,2] / (deltaq[1] ** 2) + metriccoefficients[indicesE2,1] / (deltaq[2] ** 2)))],[metriccoefficients[indicesE2,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE2,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE2,1] / (deltaq[2] ** 2)],[metriccoefficients[indicesE2,1] / (deltaq[2] ** 2)],[dot(- 0.5,metriccoefficients[indicesE2,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE2,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE2,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,metriccoefficients[indicesE2,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 2,(metriccoefficients[indicesE4,2] / (deltaq[1] ** 2) + metriccoefficients[indicesE4,1] / (deltaq[2] ** 2)))],[metriccoefficients[indicesE4,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE4,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE4,1] / (deltaq[2] ** 2)],[metriccoefficients[indicesE4,1] / (deltaq[2] ** 2)],[dot(- 0.5,metriccoefficients[indicesE4,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE4,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE4,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,metriccoefficients[indicesE4,3]) / (multiply(deltaq[1],deltaq[2]))]))
                    #elseif ~any(periodicity==1) && ~any(periodicity==2) && ~any(periodicity==3) &&  any(periodicity==4)
                else:
                    if any(periodicity == 1) and any(periodicity == 2) and logical_not(any(periodicity == 3)) and logical_not(any(periodicity == 4)):
                        pass
                    else:
                        if any(periodicity == 1) and any(periodicity == 2) and any(periodicity == 3) and any(periodicity == 4):
                            pass
        A=sparse(cat([boundaryindices],[periodicrows],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk]),cat([boundaryindices],[periodiccolumns],[effectivebulk],[effectivebulk - 1],[effectivebulk + 1],[effectivebulk - Nx],[effectivebulk + Nx],[effectivebulk - 1 - Nx],[effectivebulk + 1 - Nx],[effectivebulk - 1 + Nx],[effectivebulk + 1 + Nx]),cat([ones(size(boundaryindices,1),1)],[periodicvalues],[dot(- 2,(metriccoefficients[effectivebulk,2] / (deltaq[1] ** 2) + metriccoefficients[effectivebulk,1] / (deltaq[2] ** 2)))],[metriccoefficients[effectivebulk,2] / (deltaq[1] ** 2)],[metriccoefficients[effectivebulk,2] / (deltaq[1] ** 2)],[metriccoefficients[effectivebulk,1] / (deltaq[2] ** 2)],[metriccoefficients[effectivebulk,1] / (deltaq[2] ** 2)],[dot(- 0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))]),N,N)
        periodicvalues=matlabarray([])
        figure
        spy(A)
        hold('on')
        grid('on')
        title('Structure of solving matrix for 2D elliptic grid generation')
        clear('A','metriccoefficients')
    
    while it <= itmax and err >= tol:

        covariantbase=computecovariantbase2D(N,deltaq,lattice,firstdevneighbours)
        metriccoefficients,J=computemetriccoefficients2D(covariantbase,nargout=2)
        Pvec=sparse(P(lattice))
        Qvec=sparse(Q(lattice))
        bx=sparse(cat([boundaryindices],[periodicrows],[effectivebulk]),cat([ones(length(boundaryindices),1)],[ones(length(periodicrows),1)],[ones(length(effectivebulk),1)]),cat([lattice[boundaryindices,3]],[multiply(- (J[periodicrows,:] ** 2),(multiply(Pvec[periodicrows,:],covariantbase[periodicrows,1]) + multiply(Qvec[periodicrows,:],covariantbase[periodicrows,3])))],[multiply(- (J[effectivebulk,:] ** 2),(multiply(Pvec[effectivebulk,:],covariantbase[effectivebulk,1]) + multiply(Qvec[effectivebulk,:],covariantbase[effectivebulk,3])))]),N,1)
        by=sparse(cat([boundaryindices],[periodicrows],[effectivebulk]),cat([ones(length(boundaryindices),1)],[ones(length(periodicrows),1)],[ones(length(effectivebulk),1)]),cat([lattice[boundaryindices,4]],[multiply(- (J[periodicrows,:] ** 2),(multiply(Pvec[periodicrows,:],covariantbase[periodicrows,2]) + multiply(Qvec[periodicrows,:],covariantbase[periodicrows,4])))],[multiply(- (J[effectivebulk,:] ** 2),(multiply(Pvec[effectivebulk,:],covariantbase[effectivebulk,2]) + multiply(Qvec[effectivebulk,:],covariantbase[effectivebulk,4])))]),N,1)
        clear('covariantbase','Pvec','Qvec','J')
        if logical_not(flagperiodicity):
            periodicvalues=matlabarray([])
        else:
            if any(periodicity == 1) and logical_not(any(periodicity == 2)) and logical_not(any(periodicity == 3)) and logical_not(any(periodicity == 4)):
                periodicvalues=matlabarray(cat([dot(- 2,(metriccoefficients[indicesE1,2] / (deltaq[1] ** 2) + metriccoefficients[indicesE1,1] / (deltaq[2] ** 2)))],[metriccoefficients[indicesE1,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE1,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE1,1] / (deltaq[2] ** 2)],[metriccoefficients[indicesE1,1] / (deltaq[2] ** 2)],[dot(- 0.5,metriccoefficients[indicesE1,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE1,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE1,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,metriccoefficients[indicesE1,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 2,(metriccoefficients[indicesE3,2] / (deltaq[1] ** 2) + metriccoefficients[indicesE3,1] / (deltaq[2] ** 2)))],[metriccoefficients[indicesE3,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE3,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE3,1] / (deltaq[2] ** 2)],[metriccoefficients[indicesE3,1] / (deltaq[2] ** 2)],[dot(- 0.5,metriccoefficients[indicesE3,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE3,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE3,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,metriccoefficients[indicesE3,3]) / (multiply(deltaq[1],deltaq[2]))]))
            else:
                if logical_not(any(periodicity == 1)) and any(periodicity == 2) and logical_not(any(periodicity == 3)) and logical_not(any(periodicity == 4)):
                    periodicvalues=matlabarray(cat([dot(- 2,(metriccoefficients[indicesE2,2] / (deltaq[1] ** 2) + metriccoefficients[indicesE2,1] / (deltaq[2] ** 2)))],[metriccoefficients[indicesE2,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE2,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE2,1] / (deltaq[2] ** 2)],[metriccoefficients[indicesE2,1] / (deltaq[2] ** 2)],[dot(- 0.5,metriccoefficients[indicesE2,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE2,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE2,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,metriccoefficients[indicesE2,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 2,(metriccoefficients[indicesE4,2] / (deltaq[1] ** 2) + metriccoefficients[indicesE4,1] / (deltaq[2] ** 2)))],[metriccoefficients[indicesE4,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE4,2] / (deltaq[1] ** 2)],[metriccoefficients[indicesE4,1] / (deltaq[2] ** 2)],[metriccoefficients[indicesE4,1] / (deltaq[2] ** 2)],[dot(- 0.5,metriccoefficients[indicesE4,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE4,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[indicesE4,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,metriccoefficients[indicesE4,3]) / (multiply(deltaq[1],deltaq[2]))]))
                    #elseif ~any(periodicity==1) && ~any(periodicity==2) && ~any(periodicity==3) &&  any(periodicity==4)
                else:
                    if any(periodicity == 1) and any(periodicity == 2) and logical_not(any(periodicity == 3)) and logical_not(any(periodicity == 4)):
                        pass
                    else:
                        if any(periodicity == 1) and any(periodicity == 2) and any(periodicity == 3) and any(periodicity == 4):
                            pass
        A=sparse(cat([boundaryindices],[periodicrows],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk],[effectivebulk]),cat([boundaryindices],[periodiccolumns],[effectivebulk],[effectivebulk - 1],[effectivebulk + 1],[effectivebulk - Nx],[effectivebulk + Nx],[effectivebulk - 1 - Nx],[effectivebulk + 1 - Nx],[effectivebulk - 1 + Nx],[effectivebulk + 1 + Nx]),cat([ones(size(boundaryindices,1),1)],[periodicvalues],[dot(- 2,(metriccoefficients[effectivebulk,2] / (deltaq[1] ** 2) + metriccoefficients[effectivebulk,1] / (deltaq[2] ** 2)))],[metriccoefficients[effectivebulk,2] / (deltaq[1] ** 2)],[metriccoefficients[effectivebulk,2] / (deltaq[1] ** 2)],[metriccoefficients[effectivebulk,1] / (deltaq[2] ** 2)],[metriccoefficients[effectivebulk,1] / (deltaq[2] ** 2)],[dot(- 0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,metriccoefficients[effectivebulk,3]) / (multiply(deltaq[1],deltaq[2]))]),N,N)
        periodicvalues=matlabarray([])
        lattice[:,5]=full(numpy.linalg.solve(A,bx))
        lattice[:,6]=full(numpy.linalg.solve(A,by))
        err=sqrt(sum(cat([bx - dot(A,lattice[:,5])],[by - dot(A,lattice[:,6])]) ** 2))
        it=it + 1
        clear('A','bx','by','metriccoefficients')

    
    return lattice
# Autogenerated with SMOP 
from smop.core import *
# 

    
@function
def JFNKmethod(F=None,u0=None,tol=None,itmax=None,precond=None,alpha=None,sigma0=None,sigma1=None,*args,**kwargs):
    varargin = JFNKmethod.varargin
    nargin = JFNKmethod.nargin

    ##
#        Project: Fluid - structure interaction on deformable surfaces
#         Author: Luca Di Stasio
#    Institution: ETH Zrich
#                 Institute for Building Materials
# Research group: Computational Physics for Engineering Materials
#        Version: 0.1
#  Creation date: May 19th, 2014
#    Last update: May 21st, 2014
    
    #    Description: 
#          Input: 
#         Output:
    
    ##
    
    N=size(u0,1)
    if precond:
        epsdiff=sqrt(1 + eps(sqrt(sum(u0 ** 2)))) / sqrt(sum(u0 ** 2))
        M=(feval(F,u0 + epsdiff) - feval(u0 - epsdiff)) / (dot(2,epsdiff))
        invM=luinv(M)
    else:
        invM=eye(N)
    
    F0=feval(F,u0)
    errnewton=copy(F0)
    k=0
    while errnewton >= tol and k <= itmax:

        du0=zeros(N,1)
        err=1
        restart=0
        while err >= tol and restart <= maxrestart:

            v=zeros(N,m + 1)
            h=zeros(m + 1,m)
            if restart == 0:
                r0=- F0
            else:
                epsdiff=sqrt(1 + eps(sqrt(sum(u0 ** 2)))) / sqrt(sum(du0 ** 2))
                r0=- F0 - (feval(F,u0 + dot(epsdiff,du0)) - feval(u0 - dot(epsdiff,du0))) / (dot(2,epsdiff))
            beta=sqrt(sum(r0 ** 2))
            v[:,1]=r0 / beta
            j=1
            innerloop=1
            while innerloop and j <= m:

                zj=dot(invM,v[:,j])
                epsdiff=sqrt(1 + eps(sqrt(sum(u0 ** 2)))) / sqrt(sum(zj ** 2))
                wj=(feval(F,u0 + dot(epsdiff,zj)) - feval(u0 - dot(epsdiff,zj))) / (dot(2,epsdiff))
                for i in arange(1,j).reshape(-1):
                    h[i,j]=dot(wj.T,v[:,i])
                    wj=wj - dot(h[i,j],v[:,i])
                h[j + 1,j]=sqrt(sum(wj ** 2))
                if h[j + 1,j] == 0:
                    innerloop=0
                else:
                    v[:,j + 1]=wj / h[j + 1,j]
                    if j == m:
                        innerloop=0
                    else:
                        j=j + 1

            if j != m:
                v=v[:,1:j]
                h=h[1:j + 1,1:j]
            r=zeros(j + 1,1)
            r[1,1]=beta
            for k in arange(1,j).reshape(-1):
                P=eye(j + 1)
                s=h[k + 1,k] / (sqrt(h[k + 1,k] ** 2 + h[k,k] ** 2))
                c=h[k,k] / (sqrt(h[k + 1,k] ** 2 + h[k,k] ** 2))
                P[k,k]=c
                P[k + 1,k + 1]=c
                P[k,k + 1]=s
                P[k + 1,k]=- s
                h=dot(P,h)
                r=dot(P,r)
            y=backsolve(h[1:j,:],r[1:j,:])
            duk=du0 + dot(v[:,1:j],y)
            err=abs(r[j + 1,1])
            du0=copy(duk)
            restart=restart + 1

        lambda_=1
        u1trial=u0 + dot(lambda_,duk)
        while sqrt(sum(feval(F,u1trial) ** 2)) >= dot((1 - dot(alpha,lambda_)),sqrt(sum(feval(F,u0) ** 2))):

            sigma=sigma0 + dot(rand(1),(sigma1 - sigma0))
            lambda_=dot(sigma,lambda_)
            u1trial=u0 + dot(lambda_,duk)

        u1=copy(u1trial)
        u0=copy(u1)
        F0=feval(F,u0)
        errnewton=copy(F0)
        k=k + 1

    
    return u1
# Autogenerated with SMOP 
from smop.core import *
# 

    
@function
def ellipticgridgen2Dinternalboundaries(Nx=None,N=None,lattice=None,deltaq=None,boundary=None,indicesbulk=None,indicesE1=None,indicesE2=None,indicesE3=None,indicesE4=None,indicesC1=None,indicesC2=None,indicesC3=None,indicesC4=None,firstdevneighbours=None,itmax=None,tol=None,*args,**kwargs):
    varargin = ellipticgridgen2Dinternalboundaries.varargin
    nargin = ellipticgridgen2Dinternalboundaries.nargin

    ##
#        Project: Fluid-Structure Interaction on Deformable Surfaces
#         Author: Luca Di Stasio
#    Institution: ETH Zrich
#                 Institute for Building Materials
# Research group: Computational Physics for Engineering Materials
#        Version: 0.1
#  Creation date: July 16th, 2014
#    Last update: July 16th, 2014
    
    #          Input: meshed computational domain compdomain
#         Output: mesh in the physical domain
    
    ##
    
    boundaryindices=matlabarray(cat([indicesE1],[indicesE2],[indicesE3],[indicesE4],[indicesC1],[indicesC2],[indicesC3],[indicesC4],[boundary]))
    it=0
    err=1
    while it <= itmax and err >= tol:

        covariantbase=computecovariantbase2D(N,deltaq,lattice,firstdevneighbours)
        metriccoefficients,J=computemetriccoefficients2D(covariantbase,nargout=2)
        bx=zeros(N,1)
        by=zeros(N,1)
        bx[boundaryindices,:]=lattice[boundaryindices,3]
        by[boundaryindices,:]=lattice[boundaryindices,4]
        Pvec=P(lattice)
        Qvec=Q(lattice)
        bx[indicesbulk,:]=multiply(- (J[indicesbulk,:] ** 2),(multiply(Pvec[indicesbulk,:],covariantbase[indicesbulk,1]) + multiply(Qvec[indicesbulk,:],covariantbase[indicesbulk,3])))
        by[indicesbulk,:]=multiply(- (J[indicesbulk,:] ** 2),(multiply(Pvec[indicesbulk,:],covariantbase[indicesbulk,2]) + multiply(Qvec[indicesbulk,:],covariantbase[indicesbulk,4])))
        clear('covariantbase','Pvec','Qvec','J')
        A=eye(N)
        A[indicesbulk,indicesbulk]=diag(dot(- 2,(metriccoefficients[indicesbulk,2] / (deltaq[1] ** 2) + metriccoefficients[indicesbulk,1] / (deltaq[2] ** 2))))
        A[indicesbulk,indicesbulk - 1]=A[indicesbulk,indicesbulk - 1] + diag(metriccoefficients[indicesbulk,2] / (deltaq[1] ** 2))
        A[indicesbulk,indicesbulk + 1]=A[indicesbulk,indicesbulk + 1] + diag(metriccoefficients[indicesbulk,2] / (deltaq[1] ** 2))
        A[indicesbulk,indicesbulk - Nx]=A[indicesbulk,indicesbulk - Nx] + diag(metriccoefficients[indicesbulk,1] / (deltaq[2] ** 2))
        A[indicesbulk,indicesbulk + Nx]=A[indicesbulk,indicesbulk + Nx] + diag(metriccoefficients[indicesbulk,1] / (deltaq[2] ** 2))
        A[indicesbulk,indicesbulk - 1 - Nx]=A[indicesbulk,indicesbulk - 1 - Nx] + diag(dot(- 0.5,metriccoefficients[indicesbulk,3]) / (multiply(deltaq[1],deltaq[2])))
        A[indicesbulk,indicesbulk + 1 - Nx]=A[indicesbulk,indicesbulk + 1 - Nx] + diag(dot(0.5,metriccoefficients[indicesbulk,3]) / (multiply(deltaq[1],deltaq[2])))
        A[indicesbulk,indicesbulk - 1 + Nx]=A[indicesbulk,indicesbulk - 1 + Nx] + diag(dot(0.5,metriccoefficients[indicesbulk,3]) / (multiply(deltaq[1],deltaq[2])))
        A[indicesbulk,indicesbulk + 1 + Nx]=A[indicesbulk,indicesbulk + 1 + Nx] + diag(dot(- 0.5,metriccoefficients[indicesbulk,3]) / (multiply(deltaq[1],deltaq[2])))
        #     lattice(:,5) = gepp(A,bx);
#     lattice(:,6) = gepp(A,by);
        lattice[:,5]=numpy.linalg.solve(A,bx)
        lattice[:,6]=numpy.linalg.solve(A,by)
        err=sqrt(sum(cat([bx - dot(A,lattice[:,5])],[by - dot(A,lattice[:,6])]) ** 2))
        it=it + 1
        clear('A','bx','by','metriccoefficients')

    
    return lattice
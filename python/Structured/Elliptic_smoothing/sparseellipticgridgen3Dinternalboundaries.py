# Autogenerated with SMOP 
from smop.core import *
# 

    
@function
def sparseellipticgridgen3Dinternalboundaries(Nx=None,Ny=None,N=None,lattice=None,deltaq=None,boundary=None,indicesbulk=None,indicesF1=None,indicesF2=None,indicesF3=None,indicesF4=None,indicesF5=None,indicesF6=None,indicesE1=None,indicesE2=None,indicesE3=None,indicesE4=None,indicesE5=None,indicesE6=None,indicesE7=None,indicesE8=None,indicesE9=None,indicesE10=None,indicesE11=None,indicesE12=None,indicesC1=None,indicesC2=None,indicesC3=None,indicesC4=None,indicesC5=None,indicesC6=None,indicesC7=None,indicesC8=None,firstdevneighbours=None,itmax=None,tol=None,spyflag=None,*args,**kwargs):
    varargin = sparseellipticgridgen3Dinternalboundaries.varargin
    nargin = sparseellipticgridgen3Dinternalboundaries.nargin

    ##
#        Project: Fluid-Structure Interaction on Deformable Surfaces
#         Author: Luca Di Stasio
#    Institution: ETH Zrich
#                 Institute for Building Materials
# Research group: Computational Physics for Engineering Materials
#        Version: 0.1
#  Creation date: July 23rd, 2014
#    Last update: July 24th, 2014
    
    #          Input: meshed computational domain compdomain
#         Output: mesh in the physical domain
    
    ##
    
    boundaryindices=matlabarray(cat([indicesF1],[indicesF2],[indicesF3],[indicesF4],[indicesF5],[indicesF6],[indicesE1],[indicesE2],[indicesE3],[indicesE4],[indicesE5],[indicesE6],[indicesE7],[indicesE8],[indicesE9],[indicesE10],[indicesE11],[indicesE12],[indicesC1],[indicesC2],[indicesC3],[indicesC4],[indicesC5],[indicesC6],[indicesC7],[indicesC8],[boundary]))
    effectivebulk=matlabarray([])
    for i in arange(1,length(indicesbulk)).reshape(-1):
        if logical_not(any(boundaryindices == indicesbulk[i,1])):
            effectivebulk=matlabarray(cat([effectivebulk],[indicesbulk[i,1]]))
    
    it=0
    err=1
    if spyflag:
        covariantbase=computecovariantbase3D(N,deltaq,lattice,firstdevneighbours)
        metriccoefficients,J,sqrtg=computemetriccoefficients3D(covariantbase,nargout=3)
        clear('covariantbase','metriccoefficients','J')
        reciprocalmetriccoefficients=computereciprocalmetriccoefficients3D(computecontravariantbase3D(covariantbase,sqrtg))
        clear('covariantbase')
        G11=reciprocalmetriccoefficients[:,1]
        G22=reciprocalmetriccoefficients[:,2]
        G33=reciprocalmetriccoefficients[:,3]
        G12=reciprocalmetriccoefficients[:,4]
        G13=reciprocalmetriccoefficients[:,5]
        G23=reciprocalmetriccoefficients[:,6]
        clear('reciprocalmetriccoefficients')
        A=sparse(cat([boundaryindices],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk]),cat([boundaryindices],[indicesbulk],[indicesbulk - 1],[indicesbulk + 1],[indicesbulk - Nx],[indicesbulk + Nx],[indicesbulk - dot(Nx,Ny)],[indicesbulk + dot(Nx,Ny)],[indicesbulk - 1 - Nx],[indicesbulk + 1 - Nx],[indicesbulk - 1 + Nx],[indicesbulk + 1 + Nx],[indicesbulk - 1 - dot(Nx,Ny)],[indicesbulk + 1 - dot(Nx,Ny)],[indicesbulk - 1 + dot(Nx,Ny)],[indicesbulk + 1 + dot(Nx,Ny)],[indicesbulk - Nx - dot(Nx,Ny)],[indicesbulk + Nx - dot(Nx,Ny)],[indicesbulk - Nx + dot(Nx,Ny)],[indicesbulk + Nx + dot(Nx,Ny)]),cat([ones(size(boundaryindices,1),1)],[dot(- 2,(G11[indicesbulk] / (deltaq[1] ** 2) + G22[indicesbulk] / (deltaq[2] ** 2) + G33[indicesbulk] / (deltaq[3] ** 2)))],[G11[indicesbulk] / (deltaq[1] ** 2)],[G11[indicesbulk] / (deltaq[1] ** 2)],[G22[indicesbulk] / (deltaq[2] ** 2)],[G22[indicesbulk] / (deltaq[2] ** 2)],[G33[indicesbulk] / (deltaq[3] ** 2)],[G33[indicesbulk] / (deltaq[3] ** 2)],[dot(+ 0.5,G12[indicesbulk]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,G12[indicesbulk]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,G12[indicesbulk]) / (multiply(deltaq[1],deltaq[2]))],[dot(+ 0.5,G12[indicesbulk]) / (multiply(deltaq[1],deltaq[2]))],[dot(+ 0.5,G13[indicesbulk]) / (multiply(deltaq[1],deltaq[3]))],[dot(- 0.5,G13[indicesbulk]) / (multiply(deltaq[1],deltaq[3]))],[dot(- 0.5,G13[indicesbulk]) / (multiply(deltaq[1],deltaq[3]))],[dot(+ 0.5,G13[indicesbulk]) / (multiply(deltaq[1],deltaq[3]))],[dot(+ 0.5,G23[indicesbulk]) / (multiply(deltaq[2],deltaq[3]))],[dot(- 0.5,G23[indicesbulk]) / (multiply(deltaq[2],deltaq[3]))],[dot(- 0.5,G23[indicesbulk]) / (multiply(deltaq[2],deltaq[3]))],[dot(+ 0.5,G23[indicesbulk]) / (multiply(deltaq[2],deltaq[3]))]),N,N)
        clear('G11','G22','G33','G12','G13','G23')
        figure
        spy(A)
        hold('on')
        grid('on')
        title('Structure of solving matrix for 3D elliptic grid generation')
        clear('A')
    
    while it <= itmax and err >= tol:

        covariantbase=computecovariantbase3D(N,deltaq,lattice,firstdevneighbours)
        metriccoefficients,J,sqrtg=computemetriccoefficients3D(covariantbase,nargout=3)
        clear('metriccoefficients','J')
        reciprocalmetriccoefficients=computereciprocalmetriccoefficients3D(computecontravariantbase3D(covariantbase,sqrtg))
        Pvec=sparse(P(lattice))
        Qvec=sparse(Q(lattice))
        Rvec=sparse(R(lattice))
        bx=sparse(cat([boundaryindices],[indicesbulk]),cat([ones(length(boundaryindices),1)],[ones(length(indicesbulk),1)]),cat([lattice[boundaryindices,4]],[- (multiply(Pvec[indicesbulk,:],covariantbase[indicesbulk,1]) + multiply(Qvec[indicesbulk,:],covariantbase[indicesbulk,4]) + multiply(Rvec[indicesbulk,:],covariantbase[indicesbulk,7]))]),N,1)
        by=sparse(cat([boundaryindices],[indicesbulk]),cat([ones(length(boundaryindices),1)],[ones(length(indicesbulk),1)]),cat([lattice[boundaryindices,5]],[- (multiply(Pvec[indicesbulk,:],covariantbase[indicesbulk,2]) + multiply(Qvec[indicesbulk,:],covariantbase[indicesbulk,5]) + multiply(Rvec[indicesbulk,:],covariantbase[indicesbulk,8]))]),N,1)
        bz=sparse(cat([boundaryindices],[indicesbulk]),cat([ones(length(boundaryindices),1)],[ones(length(indicesbulk),1)]),cat([lattice[boundaryindices,6]],[- (multiply(Pvec[indicesbulk,:],covariantbase[indicesbulk,3]) + multiply(Qvec[indicesbulk,:],covariantbase[indicesbulk,6]) + multiply(Rvec[indicesbulk,:],covariantbase[indicesbulk,9]))]),N,1)
        clear('covariantbase','Pvec','Qvec')
        G11=reciprocalmetriccoefficients[:,1]
        G22=reciprocalmetriccoefficients[:,2]
        G33=reciprocalmetriccoefficients[:,3]
        G12=reciprocalmetriccoefficients[:,4]
        G13=reciprocalmetriccoefficients[:,5]
        G23=reciprocalmetriccoefficients[:,6]
        clear('metriccoefficients')
        A=sparse(cat([boundaryindices],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk],[indicesbulk]),cat([boundaryindices],[indicesbulk],[indicesbulk - 1],[indicesbulk + 1],[indicesbulk - Nx],[indicesbulk + Nx],[indicesbulk - dot(Nx,Ny)],[indicesbulk + dot(Nx,Ny)],[indicesbulk - 1 - Nx],[indicesbulk + 1 - Nx],[indicesbulk - 1 + Nx],[indicesbulk + 1 + Nx],[indicesbulk - 1 - dot(Nx,Ny)],[indicesbulk + 1 - dot(Nx,Ny)],[indicesbulk - 1 + dot(Nx,Ny)],[indicesbulk + 1 + dot(Nx,Ny)],[indicesbulk - Nx - dot(Nx,Ny)],[indicesbulk + Nx - dot(Nx,Ny)],[indicesbulk - Nx + dot(Nx,Ny)],[indicesbulk + Nx + dot(Nx,Ny)]),cat([ones(size(boundaryindices,1),1)],[dot(- 2,(G11[indicesbulk] / (deltaq[1] ** 2) + G22[indicesbulk] / (deltaq[2] ** 2) + G33[indicesbulk] / (deltaq[3] ** 2)))],[G11[indicesbulk] / (deltaq[1] ** 2)],[G11[indicesbulk] / (deltaq[1] ** 2)],[G22[indicesbulk] / (deltaq[2] ** 2)],[G22[indicesbulk] / (deltaq[2] ** 2)],[G33[indicesbulk] / (deltaq[3] ** 2)],[G33[indicesbulk] / (deltaq[3] ** 2)],[dot(+ 0.5,G12[indicesbulk]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,G12[indicesbulk]) / (multiply(deltaq[1],deltaq[2]))],[dot(- 0.5,G12[indicesbulk]) / (multiply(deltaq[1],deltaq[2]))],[dot(+ 0.5,G12[indicesbulk]) / (multiply(deltaq[1],deltaq[2]))],[dot(+ 0.5,G13[indicesbulk]) / (multiply(deltaq[1],deltaq[3]))],[dot(- 0.5,G13[indicesbulk]) / (multiply(deltaq[1],deltaq[3]))],[dot(- 0.5,G13[indicesbulk]) / (multiply(deltaq[1],deltaq[3]))],[dot(+ 0.5,G13[indicesbulk]) / (multiply(deltaq[1],deltaq[3]))],[dot(+ 0.5,G23[indicesbulk]) / (multiply(deltaq[2],deltaq[3]))],[dot(- 0.5,G23[indicesbulk]) / (multiply(deltaq[2],deltaq[3]))],[dot(- 0.5,G23[indicesbulk]) / (multiply(deltaq[2],deltaq[3]))],[dot(+ 0.5,G23[indicesbulk]) / (multiply(deltaq[2],deltaq[3]))]),N,N)
        lattice[:,7]=full(numpy.linalg.solve(A,bx))
        lattice[:,8]=full(numpy.linalg.solve(A,by))
        lattice[:,9]=full(numpy.linalg.solve(A,bz))
        err=sqrt(sum(cat([bx - dot(A,lattice[:,7])],[by - dot(A,lattice[:,8])],[bz - dot(A,lattice[:,9])]) ** 2))
        it=it + 1
        clear('A','bx','by')

    
    return lattice
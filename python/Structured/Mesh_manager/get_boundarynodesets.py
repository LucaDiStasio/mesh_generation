# Autogenerated with SMOP 
from smop.core import *
# 

    
@function
def get_boundarynodesets(inpmesh=None,type_=None,funcs=None,operator=None,bounds=None,args=None,*args,**kwargs):
    varargin = get_boundarynodesets.varargin
    nargin = get_boundarynodesets.nargin

    # integer mask for boundary type:
# 1 --> imposed displacement (for solid domain)
# 2 --> imposed velocity (for solid/fluid domain)
# 3 --> imposed flux (for fluid domain)
# 4 --> imposed density (for fluid domain)
# 5 --> imposed pressure (for fluid domain)
# 6 --> imposed distributed load (for solid domain)
# 7 --> imposed concentrated load (for solid domain)
# 8 --> fluid-solid interface (for solid/fluid domain)
# 9 --> fluid-fluid interface (for fluid domain)
# 10 --> free surface (for fluid domain)
    
    # integer mask for operator:
# 1 --> g() <
# 2 --> g() <=
# 3 --> g() ==
# 4 --> g() >=
# 5 --> g() >
# 6 --> < g() >
# 7 --> <= g() >
# 8 --> < g() >=
# 9 --> <= g() >=
    
    outmesh=copy(inpmesh)
    nbounds=length(funcs)
    outmesh.nodeboundaries = copy(zeros(nbounds,3))
    outmesh.boundarynodesets = copy([])
    for i in arange(1,nbounds).reshape(-1):
        outmesh.nodeboundaries[i,1]=i
        outmesh.nodeboundaries[i,2]=type_[i,1]
        outmesh.nodeboundaries[i,3]=length(outmesh.boundarynodesets) + 1
        checknodes=matlabarray(cat(mesh.nodes.id.T,mesh.nodes.meshcoordinates.T))
        foundnodes=matlabarray([])
        if i == nbounds:
            conditionsnum=size(type_,1) - type_[i,2]
        else:
            conditionsnum=type_[i + 1,2] - type_[i,2]
        for j in arange(1,conditionsnum).reshape(-1):
            g=inline(char(funcs[type_[i,2] + (j - 1)]),char(args[1]),char(args[2]),char(args[3]))
            if 1 == operator[type_[i,2] + (j - 1)]:
                for k in arange(1,size(checknodes,1)).reshape(-1):
                    if g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] < bounds[type_[i,2] + (j - 1),1]:
                        foundnodes=matlabarray(cat([foundnodes],[checknodes[k,:]]))
            else:
                if 2 == operator[type_[i,2] + (j - 1)]:
                    for k in arange(1,size(checknodes,1)).reshape(-1):
                        if g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] <= bounds[type_[i,2] + (j - 1),1]:
                            foundnodes=matlabarray(cat([foundnodes],[checknodes[k,:]]))
                else:
                    if 3 == operator[type_[i,2] + (j - 1)]:
                        for k in arange(1,size(checknodes,1)).reshape(-1):
                            if g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] == bounds[type_[i,2] + (j - 1),1]:
                                foundnodes=matlabarray(cat([foundnodes],[checknodes[k,:]]))
                    else:
                        if 4 == operator[type_[i,2] + (j - 1)]:
                            for k in arange(1,size(checknodes,1)).reshape(-1):
                                if g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] >= bounds[type_[i,2] + (j - 1),1]:
                                    foundnodes=matlabarray(cat([foundnodes],[checknodes[k,:]]))
                        else:
                            if 5 == operator[type_[i,2] + (j - 1)]:
                                for k in arange(1,size(checknodes,1)).reshape(-1):
                                    if g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] > bounds[type_[i,2] + (j - 1),1]:
                                        foundnodes=matlabarray(cat([foundnodes],[checknodes[k,:]]))
                            else:
                                if 6 == operator[type_[i,2] + (j - 1)]:
                                    for k in arange(1,size(checknodes,1)).reshape(-1):
                                        if g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] < bounds[type_[i,2] + (j - 1),1] and g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] > bounds[type_[i,2] + (j - 1),2]:
                                            foundnodes=matlabarray(cat([foundnodes],[checknodes[k,:]]))
                                else:
                                    if 7 == operator[type_[i,2] + (j - 1)]:
                                        for k in arange(1,size(checknodes,1)).reshape(-1):
                                            if g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] <= bounds[type_[i,2] + (j - 1),1] and g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] >= bounds[type_[i,2] + (j - 1),2]:
                                                foundnodes=matlabarray(cat([foundnodes],[checknodes[k,:]]))
                                    else:
                                        if 8 == operator[type_[i,2] + (j - 1)]:
                                            for k in arange(1,size(checknodes,1)).reshape(-1):
                                                if g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] < bounds[type_[i,2] + (j - 1),1] and g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] > bounds[type_[i,2] + (j - 1),2]:
                                                    foundnodes=matlabarray(cat([foundnodes],[checknodes[k,:]]))
                                        else:
                                            if 9 == operator[type_[i,2] + (j - 1)]:
                                                for k in arange(1,size(checknodes,1)).reshape(-1):
                                                    if g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] <= bounds[type_[i,2] + (j - 1),1] and g[checknodes[k,2],checknodes[k,3],checknodes[k,4]] >= bounds[type_[i,2] + (j - 1),2]:
                                                        foundnodes=matlabarray(cat([foundnodes],[checknodes[k,:]]))
                                            else:
                                                disp('The flag provided does not correspond to any operator.')
            checknodes=copy(foundnodes)
            foundnodes=matlabarray([])
        outmesh.boundarynodesets = copy(cat([outmesh.boundarynodesets],[checknodes[:,1]]))
    
    return outmesh
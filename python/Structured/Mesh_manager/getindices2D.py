# Autogenerated with SMOP 
from smop.core import *
# 

    
@function
def getindices2D(Nx=None,Ny=None,*args,**kwargs):
    varargin = getindices2D.varargin
    nargin = getindices2D.nargin

    ##
#==============================================================================
# Copyright (c) 2016 Universit de Lorraine & Lule tekniska universitet
# Author: Luca Di Stasio <luca.distasio@gmail.com>
#                        <luca.distasio@ingpec.eu>
    
    # Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 
# Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in
# the documentation and/or other materials provided with the distribution
# Neither the name of the Universit de Lorraine or Lule tekniska universitet
# nor the names of its contributors may be used to endorse or promote products
# derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#==============================================================================
    
    #  DESCRIPTION
#  
#  A function to
    
    ##
    
    indicesbulk=zeros(dot((Nx - 2),(Ny - 2)),1)
    for j in arange(1,Ny - 2).reshape(-1):
        for i in arange(1,Nx - 2).reshape(-1):
            indicesbulk[i + dot((j - 1),(Nx - 2)),1]=(i + 1) + dot(j,Nx)
    
    indicesinternalbulk=zeros(dot((Nx - 4),(Ny - 4)),1)
    for j in arange(1,Ny - 4).reshape(-1):
        for i in arange(1,Nx - 4).reshape(-1):
            indicesinternalbulk[i + dot((j - 1),(Nx - 4)),1]=(i + 2) + dot((j + 1),Nx)
    
    # edges
    
    indicesE1=zeros(Nx - 2,1)
    
    for i in arange(1,Nx - 2).reshape(-1):
        j=1
        indicesE1[i,1]=(i + 1) + dot((j - 1),Nx)
    
    indicesE2=zeros(Ny - 2,1)
    
    for j in arange(1,Ny - 2).reshape(-1):
        i=copy(Nx)
        indicesE2[j,1]=i + dot(j,Nx)
    
    indicesE3=zeros(Nx - 2,1)
    
    for i in arange(1,Nx - 2).reshape(-1):
        j=copy(Ny)
        indicesE3[i,1]=(i + 1) + dot((j - 1),Nx)
    
    indicesE4=zeros(Ny - 2,1)
    
    for j in arange(1,Ny - 2).reshape(-1):
        i=1
        indicesE4[j,1]=i + dot(j,Nx)
    
    indicesinternalE1=zeros(Nx - 4,1)
    
    for i in arange(1,Nx - 4).reshape(-1):
        j=2
        indicesinternalE1[i,1]=(i + 2) + dot((j - 1),Nx)
    
    indicesinternalE2=zeros(Ny - 4,1)
    
    for j in arange(1,Ny - 4).reshape(-1):
        i=Nx - 1
        indicesinternalE2[j,1]=i + dot((j + 1),Nx)
    
    indicesinternalE3=zeros(Nx - 4,1)
    
    for i in arange(1,Nx - 4).reshape(-1):
        j=Ny - 1
        indicesinternalE3[i,1]=(i + 2) + dot((j - 1),Nx)
    
    indicesinternalE4=zeros(Ny - 4,1)
    
    for j in arange(1,Ny - 4).reshape(-1):
        i=2
        indicesinternalE4[j,1]=i + dot((j + 1),Nx)
    
    indicesexternalE1=indicesE1[indicesE1[indicesE1 != 2] != Nx - 1]
    indicesexternalE2=indicesE2[indicesE2[indicesE2 != dot(2,Nx)] != Nx + dot((Ny - 2),Nx)]
    indicesexternalE3=indicesE3[indicesE3[indicesE3 != dot(Nx,Ny) - 1] != 2 + dot((Ny - 1),Nx)]
    indicesexternalE4=indicesE4[indicesE4[indicesE4 != 1 + Nx] != 1 + dot((Ny - 2),Nx)]
    # corners
    
    indicesC1=1
    indicesC2=copy(Nx)
    indicesC3=Nx + dot(Nx,(Ny - 1))
    indicesC4=1 + dot(Nx,(Ny - 1))
    indicesinternalC1=matlabarray(cat([2 + Nx + dot(Nx,Ny)],[2],[1 + Nx]))
    indicesinternalC2=matlabarray(cat([(Nx - 1) + Nx + dot(Nx,Ny)],[Nx - 1],[dot(2,Nx)]))
    indicesinternalC3=matlabarray(cat([dot(Nx,Ny) - Nx - 1 + dot(Nx,Ny)],[Nx + dot((Ny - 2),Nx)],[dot(Nx,Ny) - 1]))
    indicesinternalC4=matlabarray(cat([2 + dot(Nx,(Ny - 2)) + dot(Nx,Ny)],[1 + dot((Ny - 2),Nx)],[2 + dot((Ny - 1),Nx)]))
    return indicesbulk,indicesinternalbulk,indicesE1,indicesE2,indicesE3,indicesE4,indicesexternalE1,indicesexternalE2,indicesexternalE3,indicesexternalE4,indicesinternalE1,indicesinternalE2,indicesinternalE3,indicesinternalE4,indicesC1,indicesC2,indicesC3,indicesC4,indicesinternalC1,indicesinternalC2,indicesinternalC3,indicesinternalC4
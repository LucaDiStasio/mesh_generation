# Autogenerated with SMOP 
from smop.core import *
# 

    
@function
def tri6quality(nodes=None,elements=None,*args,**kwargs):
    varargin = tri6quality.varargin
    nargin = tri6quality.nargin

    ##
#==============================================================================
# Copyright (c) 2016 Universit de Lorraine & Lule tekniska universitet
# Author: Luca Di Stasio <luca.distasio@gmail.com>
#                        <luca.distasio@ingpec.eu>
    
    # Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 
# Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in
# the documentation and/or other materials provided with the distribution
# Neither the name of the Universit de Lorraine or Lule tekniska universitet
# nor the names of its contributors may be used to endorse or promote products
# derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#==============================================================================
    
    #  DESCRIPTION
#  A function to measure quality metrics of a mesh with triangular
#  elements
    
    # REFERENCES
# [1] J. Robinson, CRE method of element testing and the Jacobian shape parameters. Engineering Computations 4(1987) 2 113-118.
#     Link: http://www.emeraldinsight.com.bases-doc.univ-lorraine.fr/doi/pdfplus/10.1108/eb023689
# [2] J. Robinson, Distortion Measures for Quadrilaterals with Curved Boundaries. Finite Elements in Analysis and Design 4(1988) 115-131.
#     Link: http://ac.els-cdn.com.bases-doc.univ-lorraine.fr/0168874X88900017/1-s2.0-0168874X88900017-main.pdf?_tid=676ee6a2-3e07-11e6-9259-00000aacb35e&acdnat=1467211400_b34d2ec8b3a9c1fd6175ca07c1db6f16
# [3] J. Robinson, Quadrilateral and hexahedron shape parameters. Finite Elements in Analysis and Design 16(1994) 43-52.
#     Link: http://ac.els-cdn.com.bases-doc.univ-lorraine.fr/0168874X94900396/1-s2.0-0168874X94900396-main.pdf?_tid=ea951228-3e06-11e6-960c-00000aab0f6b&acdnat=1467211190_a5c8c45addbc80b7b57e177c2e059e2f
# [4] P. Knupp, Achieving Finite Element Mesh Quality via Optimization of the Jacobian Matrix Norm and Associated Quantities, Part I. Int. J. Num. Meth. Engr. 2000.
#     Link: http://www.ann.jussieu.fr/~frey/papers/meshing/Knupp#20P.,#20Achieving#20#F4#8F#B0#A3nite#20element#20mesh#20quality#20via#20optimization#20#20of#20the#20Jacobian#20matrix#20norm#20(1).pdf
# [5] P. Knupp, Label-Invariant Mesh Quality Metrics.
#     Link: http://imr.sandia.gov/papers/imr18/Knupp.pdf
# [6] P. Knupp, Algebraic Mesh Quality Metrics. SIAM Journal of Scientific Computing 23(2001),1 193-218
#     Link: http://imr.sandia.gov/papers/imr18/Knupp.pdf
# [7] P. Knupp, Algebraic mesh quality metrics for unstructured initial meshes. Finite Elements in Analysis and Design 39:3(2003) 217-241
#     Link: http://www.sciencedirect.com.bases-doc.univ-lorraine.fr/science/article/pii/S0168874X02000707
# [8] Cubit 14.0 User Documentation.
#     Link: https://cubit.sandia.gov/public/14.0/help_manual/WebHelp/mesh_generation/mesh_quality_assessment/triangular_metrics.htm
##
    
    x1=nodes[elements[:,1],1]
    x2=nodes[elements[:,2],1]
    x3=nodes[elements[:,3],1]
    x4=nodes[elements[:,4],1]
    x5=nodes[elements[:,5],1]
    x6=nodes[elements[:,6],1]
    y1=nodes[elements[:,1],2]
    y2=nodes[elements[:,2],2]
    y3=nodes[elements[:,3],2]
    y4=nodes[elements[:,4],2]
    y5=nodes[elements[:,5],2]
    y6=nodes[elements[:,6],2]
    
    edge1=matlabarray(cat(x2 - x1,y2 - y1))
    edge2=matlabarray(cat(x3 - x2,y3 - y2))
    edge3=matlabarray(cat(x3 - x1,y3 - y1))
    lengths=matlabarray(cat(sqrt(sum(edge1 ** 2,2)),sqrt(sum(edge2 ** 2,2)),sqrt(sum(edge3 ** 2,2))))
    minL=min(lengths,[],2)
    maxL=max(lengths,[],2)
    meanL=mean(lengths,[],2)
    
    alphas=multiply(cat(acos(sum(multiply(edge3,edge1),2) / (multiply(lengths[:,3],lengths[:,1]))),acos(sum(multiply(- edge1,edge2),2) / (multiply(lengths[:,1],lengths[:,2]))),acos(sum(multiply(- edge2,(- edge3)),2) / (multiply(lengths[:,2],lengths[:,3])))),(180 / pi))
    minAlpha=min(alphas,[],2)
    maxAlpha=max(alphas,[],2)
    meanAlpha=mean(alphas,[],2)
    vckB12=matlabarray(cat(x4 - dot(0.5,(x1 + x2)),y4 - dot(0.5,(y1 + y2))))
    
    vckB23=matlabarray(cat(x5 - dot(0.5,(x3 + x2)),y5 - dot(0.5,(y3 + y2))))
    
    vckB13=matlabarray(cat(x6 - dot(0.5,(x1 + x3)),y6 - dot(0.5,(y1 + y3))))
    
    # Edges' tangential unit vector of chord quadrilateral (as vectors in the plane)
    dirEdge1=edge1 / cat(lengths[:,1],lengths[:,1])
    dirEdge2=edge2 / cat(lengths[:,2],lengths[:,2])
    dirEdge3=edge3 / cat(lengths[:,3],lengths[:,3])
    
    norEdge1=matlabarray(cat(dirEdge1[:,2],- dirEdge1[:,1]))
    norEdge2=matlabarray(cat(dirEdge2[:,2],- dirEdge2[:,1]))
    norEdge3=matlabarray(cat(dirEdge3[:,2],- dirEdge3[:,1]))
    
    TD=dot(2,cat((multiply(vckB12[:,1],dirEdge1[:,1]) + multiply(vckB12[:,2],dirEdge1[:,2])) / lengths[:,1],(multiply(vckB23[:,1],dirEdge2[:,1]) + multiply(vckB23[:,2],dirEdge2[:,2])) / lengths[:,2],(multiply(vckB13[:,1],dirEdge3[:,1]) + multiply(vckB13[:,2],dirEdge3[:,2])) / lengths[:,3]))
    
    ND=dot(2,cat((multiply(vckB12[:,1],norEdge1[:,1]) + multiply(vckB12[:,2],norEdge1[:,2])) / lengths[:,1],(multiply(vckB23[:,1],norEdge2[:,1]) + multiply(vckB23[:,2],norEdge2[:,2])) / lengths[:,2],(multiply(vckB13[:,1],norEdge3[:,1]) + multiply(vckB13[:,2],norEdge3[:,2])) / lengths[:,3]))
    
    J=matlabarray(cat((dot((x4 - x1),(y6 - y1)) - dot((y4 - y1),(x6 - x1))),(dot((x2 - x4),(y5 - y2)) - dot((y2 - y4),(x5 - x2))),(dot((x3 - x6),(y3 - y5)) - dot((y3 - y6),(x3 - x5)))))
    
    gammas=matlabarray(cat(acos(sum(multiply(cat(x4 - x1,y4 - y1),edge1),2) / (multiply(lengths[:,1],sqrt(sum(cat(x4 - x1,y4 - y1) ** 2,2))))),acos(sum(multiply(cat(x5 - x2,y5 - y2),edge2),2) / (multiply(lengths[:,2],sqrt(sum(cat(x5 - x2,y5 - y2) ** 2,2))))),acos(sum(multiply(cat(x6 - x1,y6 - y1),edge3),2) / (multiply(lengths[:,3],sqrt(sum(cat(x6 - x1,y6 - y1) ** 2,2)))))))
    
    A=multiply(multiply(dot(0.5,lengths[:,1]),lengths[:,3]),sin(multiply(alphas[:,1],(pi / 180)))) + multiply(dot(multiply(sign(ND[:,1]),0.5),(multiply(lengths[:,1],sqrt(sum(cat(x4 - x1,y4 - y1) ** 2,2))))),sin(gammas[:,1])) + multiply(dot(multiply(sign(ND[:,2]),0.5),(multiply(lengths[:,2],sqrt(sum(cat(x5 - x2,y5 - y2) ** 2,2))))),sin(gammas[:,2])) + multiply(dot(multiply(sign(ND[:,3]),0.5),(multiply(lengths[:,3],sqrt(sum(cat(x6 - x1,y6 - y1) ** 2,2))))),sin(gammas[:,3]))
    minA=min(A)
    maxA=max(A)
    meanA=mean(A)
    
    JA=J / cat(A,A,A)
    lambda11=lengths[:,1] ** 2
    lambda22=lengths[:,3] ** 2
    lambda12=dot(sqrt(multiply(lambda11,lambda22)),cos(alphas[:,1]))
    J1=sqrt(multiply(multiply(lambda11,lambda22),(sin(alphas[:,1]) ** 2)))
    JA1=J1 / A
    fshape=dot(sqrt(3),J1) / (lambda11 + lambda22 - lambda12)
    
    return fshape,TD,ND,minL,maxL,meanL,minAlpha,maxAlpha,meanAlpha,A,minA,maxA,meanA,J,JA,J1,JA1
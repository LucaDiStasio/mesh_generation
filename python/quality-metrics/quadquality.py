# Autogenerated with SMOP 
from smop.core import *
# 

    
@function
def quadquality(nodes=None,elements=None,*args,**kwargs):
    varargin = quadquality.varargin
    nargin = quadquality.nargin

    ##
#==============================================================================
# Copyright (c) 2016 Universit de Lorraine & Lule tekniska universitet
# Author: Luca Di Stasio <luca.distasio@gmail.com>
#                        <luca.distasio@ingpec.eu>
    
    # Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 
# Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in
# the documentation and/or other materials provided with the distribution
# Neither the name of the Universit de Lorraine or Lule tekniska universitet
# nor the names of its contributors may be used to endorse or promote products
# derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#==============================================================================
    
    #  DESCRIPTION
#  
#  A function to measure quality metrics of a mesh with quadrilateral
#  elements
    
    # REFERENCES
# [1] J. Robinson, CRE method of element testing and the Jacobian shape parameters. Engineering Computations 4(1987) 2 113-118.
#     Link: http://www.emeraldinsight.com.bases-doc.univ-lorraine.fr/doi/pdfplus/10.1108/eb023689
# [2] J. Robinson, Distortion Measures for Quadrilaterals with Curved Boundaries. Finite Elements in Analysis and Design 4(1988) 115-131.
#     Link: http://ac.els-cdn.com.bases-doc.univ-lorraine.fr/0168874X88900017/1-s2.0-0168874X88900017-main.pdf?_tid=676ee6a2-3e07-11e6-9259-00000aacb35e&acdnat=1467211400_b34d2ec8b3a9c1fd6175ca07c1db6f16
# [3] J. Robinson, Quadrilateral and hexahedron shape parameters. Finite Elements in Analysis and Design 16(1994) 43-52.
#     Link: http://ac.els-cdn.com.bases-doc.univ-lorraine.fr/0168874X94900396/1-s2.0-0168874X94900396-main.pdf?_tid=ea951228-3e06-11e6-960c-00000aab0f6b&acdnat=1467211190_a5c8c45addbc80b7b57e177c2e059e2f
# [4] P. Knupp, Achieving Finite Element Mesh Quality via Optimization of the Jacobian Matrix Norm and Associated Quantities, Part I. Int. J. Num. Meth. Engr. 2000.
#     Link: http://www.ann.jussieu.fr/~frey/papers/meshing/Knupp#20P.,#20Achieving#20#F4#8F#B0#A3nite#20element#20mesh#20quality#20via#20optimization#20#20of#20the#20Jacobian#20matrix#20norm#20(1).pdf
# [5] P. Knupp, Label-Invariant Mesh Quality Metrics.
#     Link: http://imr.sandia.gov/papers/imr18/Knupp.pdf
# [6] P. Knupp, Algebraic Mesh Quality Metrics. SIAM Journal of Scientific Computing 23(2001),1 193-218
#     Link: http://imr.sandia.gov/papers/imr18/Knupp.pdf
# [7] Cubit 14.0 User Documentation.
#     Link: https://cubit.sandia.gov/public/14.0/help_manual/WebHelp/mesh_generation/mesh_quality_assessment/quadrilateral_metrics.htm
##
    
    if 4 == size(elements,2):
        # Nodes
        x1=nodes[elements[:,1],1]
        x2=nodes[elements[:,2],1]
        x3=nodes[elements[:,3],1]
        x4=nodes[elements[:,4],1]
        y1=nodes[elements[:,1],2]
        y2=nodes[elements[:,2],2]
        y3=nodes[elements[:,3],2]
        y4=nodes[elements[:,4],2]
        edge1=matlabarray(cat(x2 - x1,y2 - y1))
        edge2=matlabarray(cat(x3 - x2,y3 - y2))
        edge3=matlabarray(cat(x3 - x4,y3 - y4))
        edge4=matlabarray(cat(x4 - x1,y4 - y1))
        diag1=matlabarray(cat(x3 - x1,y3 - y1))
        diag2=matlabarray(cat(x4 - x2,y4 - y2))
        lengths=matlabarray(cat(sqrt(sum(edge1 ** 2,2)),sqrt(sum(edge2 ** 2,2)),sqrt(sum(edge3 ** 2,2)),sqrt(sum(edge4 ** 2,2))))
        minL=min(lengths,[],2)
        maxL=max(lengths,[],2)
        meanL=mean(lengths,[],2)
        alphas=multiply(cat(acos(sum(multiply(edge4,edge1),2) / (multiply(lengths[:,4],lengths[:,1]))),acos(sum(multiply(- edge1,edge2),2) / (multiply(lengths[:,1],lengths[:,2]))),acos(sum(multiply(- edge2,(- edge3)),2) / (multiply(lengths[:,2],lengths[:,3]))),acos(sum(multiply(edge3,(- edge4)),2) / (multiply(lengths[:,3],lengths[:,4])))),(180 / pi))
        minAlpha=min(alphas,[],2)
        maxAlpha=max(alphas,[],2)
        meanAlpha=mean(alphas,[],2)
        Dlengths=matlabarray(cat(sqrt(sum(diag1 ** 2,2)),sqrt(sum(diag2 ** 2,2))))
        minD=min(Dlengths,[],2)
        maxD=max(Dlengths,[],2)
        meanD=mean(Dlengths,[],2)
        betas=multiply(acos(sum(multiply(diag1,diag2),2) / (multiply(Dlengths[:,1],Dlengths[:,2]))),(180 / pi))
        betas=matlabarray(cat(betas,180 - betas))
        A=dot(0.5,(multiply(multiply(lengths[:,1],lengths[:,4]),sin(multiply(alphas[:,1],(pi / 180)))) + multiply(multiply(lengths[:,2],lengths[:,3]),sin(multiply(alphas[:,3],(pi / 180))))))
        e1=dot(0.25,(x1 + x2 + x3 + x4))
        e2=dot(0.25,(- x1 + x2 + x3 - x4))
        e3=dot(0.25,(- x1 - x2 + x3 + x4))
        e4=dot(0.25,(x1 - x2 + x3 - x4))
        f1=dot(0.25,(y1 + y2 + y3 + y4))
        f2=dot(0.25,(- y1 + y2 + y3 - y4))
        f3=dot(0.25,(- y1 - y2 + y3 + y4))
        f4=dot(0.25,(y1 - y2 + y3 - y4))
        ar=max(e2 / f3,f3 / e2)
        skew=e3 / f3
        Tx=f4 / f3
        Ty=e4 / e2
        stretch=multiply(sqrt(2),minL) / maxD
        # Jacobian at:
        J=matlabarray(cat(dot(f3 ** 2.0,ar),multiply(dot(f3 ** 2.0,ar),(1 + dot(Tx,(- 1)) + dot((Ty - multiply((skew / ar),Tx)),(- 1)))),multiply(dot(f3 ** 2.0,ar),(1 + dot(Tx,(1)) + dot((Ty - multiply((skew / ar),Tx)),(- 1)))),multiply(dot(f3 ** 2.0,ar),(1 + dot(Tx,(1)) + dot((Ty - multiply((skew / ar),Tx)),(1)))),multiply(dot(f3 ** 2.0,ar),(1 + dot(Tx,(- 1)) + dot((Ty - multiply((skew / ar),Tx)),(1))))))
        # Ratio of Jacobian to actual area
        JA=J / cat(A,A,A,A,A)
    else:
        if 8 == size(elements,2):
            # Nodes
            x1=nodes[elements[:,1],1]
            x2=nodes[elements[:,2],1]
            x3=nodes[elements[:,3],1]
            x4=nodes[elements[:,4],1]
            x5=nodes[elements[:,5],1]
            x6=nodes[elements[:,6],1]
            x7=nodes[elements[:,7],1]
            x8=nodes[elements[:,8],1]
            y1=nodes[elements[:,1],2]
            y2=nodes[elements[:,2],2]
            y3=nodes[elements[:,3],2]
            y4=nodes[elements[:,4],2]
            y5=nodes[elements[:,5],2]
            y6=nodes[elements[:,6],2]
            y7=nodes[elements[:,7],2]
            y8=nodes[elements[:,8],2]
            edge1=matlabarray(cat(x2 - x1,y2 - y1))
            edge2=matlabarray(cat(x3 - x2,y3 - y2))
            edge3=matlabarray(cat(x3 - x4,y3 - y4))
            edge4=matlabarray(cat(x4 - x1,y4 - y1))
            diag1=matlabarray(cat(x3 - x1,y3 - y1))
            diag2=matlabarray(cat(x4 - x2,y4 - y2))
            e1=dot(- 0.25,(x1 + x2 + x3 + x4)) + dot(0.5,(x5 + x6 + x7 + x8))
            e2=dot(0.5,(x6 - x8))
            e3=dot(0.5,(- x5 + x7))
            e4=dot(0.25,(x1 - x2 + x3 - x4))
            e5=dot(0.25,(x1 + x2 + x3 + x4)) - dot(0.5,(x5 + x7))
            e6=dot(0.25,(x1 + x2 + x3 + x4)) - dot(0.5,(x6 + x8))
            e7=dot(0.25,(- x1 - x2 + x3 + x4)) + dot(0.5,(x5 - x7))
            e8=dot(0.25,(- x1 + x2 + x3 - x4)) + dot(0.5,(- x6 + x8))
            f1=dot(- 0.25,(y1 + y2 + y3 + y4)) + dot(0.5,(y5 + y6 + y7 + y8))
            f2=dot(0.5,(y6 - y8))
            f3=dot(0.5,(- y5 + y7))
            f4=dot(0.25,(y1 - y2 + y3 - y4))
            f5=dot(0.25,(y1 + y2 + y3 + y4)) - dot(0.5,(y5 + y7))
            f6=dot(0.25,(y1 + y2 + y3 + y4)) - dot(0.5,(y6 + y8))
            f7=dot(0.25,(- y1 - y2 + y3 + y4)) + dot(0.5,(y5 - y7))
            f8=dot(0.25,(- y1 + y2 + y3 - y4)) + dot(0.5,(- y6 + y8))
            ar=max(e2 / f3,f3 / e2)
            skew=e3 / f3 + f2 / e2
            Tx=f4 / f3
            Ty=e4 / e2
            vckB12=matlabarray(cat(- (e5 - e7),- (f5 - f7)))
            vckB23=matlabarray(cat(- (e6 + e8),- (f6 + f8)))
            vckB34=matlabarray(cat(- (e5 + e7),- (f5 + f7)))
            vckB41=matlabarray(cat(- (e6 - e8),- (f6 - f8)))
            # Edges' length of chord quadrilateral
            lengths=matlabarray(cat(sqrt(sum(edge1 ** 2,2)),sqrt(sum(edge2 ** 2,2)),sqrt(sum(edge3 ** 2,2)),sqrt(sum(edge4 ** 2,2))))
            minL=min(lengths,[],2)
            maxL=max(lengths,[],2)
            meanL=mean(lengths,[],2)
            alphas=multiply(cat(acos(sum(multiply(edge4,edge1),2) / (multiply(lengths[:,4],lengths[:,1]))),acos(sum(multiply(- edge1,edge2),2) / (multiply(lengths[:,1],lengths[:,2]))),acos(sum(multiply(- edge2,(- edge3)),2) / (multiply(lengths[:,2],lengths[:,3]))),acos(sum(multiply(edge3,(- edge4)),2) / (multiply(lengths[:,3],lengths[:,4])))),(180 / pi))
            minAlpha=min(alphas,[],2)
            maxAlpha=max(alphas,[],2)
            meanAlpha=mean(alphas,[],2)
            Dlengths=matlabarray(cat(sqrt(sum(diag1 ** 2,2)),sqrt(sum(diag2 ** 2,2))))
            minD=min(Dlengths,[],2)
            maxD=max(Dlengths,[],2)
            meanD=mean(Dlengths,[],2)
            betas=multiply(acos(sum(multiply(diag1,diag2),2) / (multiply(Dlengths[:,1],Dlengths[:,2]))),(180 / pi))
            betas=matlabarray(cat(betas,180 - betas))
            dirEdge1=edge1 / cat(lengths[:,1],lengths[:,1])
            dirEdge2=edge2 / cat(lengths[:,2],lengths[:,2])
            dirEdge3=edge3 / cat(lengths[:,3],lengths[:,3])
            dirEdge4=edge4 / cat(lengths[:,4],lengths[:,4])
            norEdge1=matlabarray(cat(dirEdge1[:,2],- dirEdge1[:,1]))
            norEdge2=matlabarray(cat(dirEdge2[:,2],- dirEdge2[:,1]))
            norEdge3=matlabarray(cat(dirEdge3[:,2],- dirEdge3[:,1]))
            norEdge4=matlabarray(cat(dirEdge4[:,2],- dirEdge4[:,1]))
            TD=dot(2,cat((multiply(vckB12[:,1],dirEdge1[:,1]) + multiply(vckB12[:,2],dirEdge1[:,2])) / lengths[:,1],(multiply(vckB23[:,1],dirEdge2[:,1]) + multiply(vckB23[:,2],dirEdge2[:,2])) / lengths[:,2],(multiply(vckB34[:,1],dirEdge3[:,1]) + multiply(vckB34[:,2],dirEdge3[:,2])) / lengths[:,3],(multiply(vckB41[:,1],dirEdge4[:,1]) + multiply(vckB41[:,2],dirEdge4[:,2])) / lengths[:,4]))
            ND=dot(2,cat((multiply(vckB12[:,1],norEdge1[:,1]) + multiply(vckB12[:,2],norEdge1[:,2])) / lengths[:,1],(multiply(vckB23[:,1],norEdge2[:,1]) + multiply(vckB23[:,2],norEdge2[:,2])) / lengths[:,2],(multiply(vckB34[:,1],norEdge3[:,1]) + multiply(vckB34[:,2],norEdge3[:,2])) / lengths[:,3],(multiply(vckB41[:,1],norEdge4[:,1]) + multiply(vckB41[:,2],norEdge4[:,2])) / lengths[:,4]))
            J=matlabarray(cat((dot((x5 - x1),(y8 - y1)) - dot((y5 - y1),(x8 - x1))),(dot((x2 - x5),(y6 - y2)) - dot((y2 - y5),(x6 - x2))),(dot((x3 - x7),(y3 - y6)) - dot((y3 - y7),(x3 - x6))),(dot((x7 - x4),(y4 - y8)) - dot((y7 - y4),(x4 - x8)))))
            gammas=matlabarray(cat(acos(sum(multiply(cat(x5 - x1,y5 - y1),edge1),2) / (multiply(lengths[:,1],sqrt(sum(cat(x5 - x1,y5 - y1) ** 2,2))))),acos(sum(multiply(cat(x6 - x2,y6 - y2),edge2),2) / (multiply(lengths[:,2],sqrt(sum(cat(x6 - x2,y6 - y2) ** 2,2))))),acos(sum(multiply(cat(x7 - x4,y7 - y4),edge3),2) / (multiply(lengths[:,3],sqrt(sum(cat(x7 - x4,y7 - y4) ** 2,2))))),acos(sum(multiply(cat(x8 - x1,y8 - y1),edge4),2) / (multiply(lengths[:,4],sqrt(sum(cat(x8 - x1,y8 - y1) ** 2,2)))))))
            A=dot(0.5,(multiply(multiply(lengths[:,1],lengths[:,4]),sin(multiply(alphas[:,1],(pi / 180)))) + multiply(multiply(lengths[:,2],lengths[:,3]),sin(multiply(alphas[:,3],(pi / 180)))))) + multiply(dot(multiply(sign(ND[:,1]),0.5),(multiply(lengths[:,1],sqrt(sum(cat(x5 - x1,y5 - y1) ** 2,2))))),sin(gammas[:,1])) + multiply(dot(multiply(sign(ND[:,2]),0.5),(multiply(lengths[:,2],sqrt(sum(cat(x6 - x2,y6 - y2) ** 2,2))))),sin(gammas[:,2])) + multiply(dot(multiply(sign(ND[:,3]),0.5),(multiply(lengths[:,3],sqrt(sum(cat(x7 - x4,y7 - y4) ** 2,2))))),sin(gammas[:,3])) + multiply(dot(multiply(sign(ND[:,4]),0.5),(multiply(lengths[:,4],sqrt(sum(cat(x8 - x1,y8 - y1) ** 2,2))))),sin(gammas[:,4]))
            JA=J / cat(A,A,A,A)
    
    return
    
if __name__ == '__main__':
    pass
    